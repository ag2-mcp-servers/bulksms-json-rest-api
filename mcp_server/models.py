# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T17:33:10+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, List, Optional

from pydantic import BaseModel, Field, RootModel


class Error(BaseModel):
    detail: Optional[str] = Field(
        None, description='More information about why the error occurred.'
    )
    status: int = Field(..., description='The HTTP status code')
    title: str = Field(..., description='A short description of the type')
    type: str = Field(..., description='A URL to one of the [error types](errors/).')


class Encoding(Enum):
    TEXT = 'TEXT'
    UNICODE = 'UNICODE'
    BINARY = 'BINARY'


class Subtype(Enum):
    EXPIRED = 'EXPIRED'
    HANDSET_ERROR = 'HANDSET_ERROR'
    BLOCKED = 'BLOCKED'
    NOT_SENT = 'NOT_SENT'


class Type(Enum):
    ACCEPTED = 'ACCEPTED'
    SCHEDULED = 'SCHEDULED'
    SENT = 'SENT'
    DELIVERED = 'DELIVERED'
    UNKNOWN = 'UNKNOWN'
    FAILED = 'FAILED'


class Status(BaseModel):
    id: str = Field(
        ...,
        description='A concatenated value A.B where A is the `status.type` and B is the `status.subtype`.  \nIt there is no value for `subtype` then B takes string value `"null"` (e.g. `"SENT.null"`).   \n',
    )
    subtype: Optional[Subtype] = Field(
        None,
        description='Has a value only if the `type` is FAILED.\n\nEXPIRED  Delivery failed because message expired before delivery was possible.\n\nHANDSET_ERROR  Delivery failed because of a problem related to the phone (e.g. message storage area full).\n\nBLOCKED  Your account has been blocked from sending to this phone (e.g. recipient replied STOP to block communication).\n\nNOT_SENT  Message delivery was not attempted (e.g. because we were not able to find a route for the supplied phone number).\n',
    )
    type: Type = Field(
        ...,
        description='\nACCEPTED  Message accepted for delivery. Only returned for initial message submissions.\n\nSCHEDULED  Message accepted for delivery at a later date. Only returned for initial message  submissions.\n\nSENT  Message has been relayed away from our systems.\n\nDELIVERED  Successfully delivered to phone.\n\nUNKNOWN  Message is in an unknown state.\n\nFAILED  Delivery failed.\n',
    )


class Submission(BaseModel):
    date: datetime = Field(
        ...,
        description='The date and time the submission was processed. If the `type` is RECEIVED, this field reflects the date and time the received message was processed.',
    )
    id: str = Field(
        ...,
        description='A unique identity shared by all messages that were created from the same submission. This field should be ignored if the `type` is not SENT.',
    )


class Type1(Enum):
    SENT = 'SENT'
    RECEIVED = 'RECEIVED'


class Message(BaseModel):
    body: Any = Field(..., description='The content of the message')
    creditCost: Optional[float] = Field(
        None,
        description='The cost of the message (in credits).   Note that this field does not have a value in the submission response.',
    )
    encoding: Optional[Encoding] = Field(
        None,
        description='The type of the content.  See the `encoding` field for more information.',
    )
    from_: Optional[str] = Field(
        None, alias='from', description='The address part of the sender id'
    )
    id: str = Field(
        ...,
        description='A unique identifier that is assigned when the message is created.',
    )
    messageClass: Optional[int] = Field(
        None, description='See the `messageClass` field for more information.'
    )
    numberOfParts: Optional[int] = Field(
        None,
        description='The number of parts.  If this is a concatenated message, the number of parts will be more than 1.  Note that this field does not have a value in the submission response.',
    )
    protocolId: Optional[int] = Field(
        None, description='See the `protocolId` field for more information.'
    )
    relatedSentMessageId: Optional[str] = Field(
        None,
        description='This field has a value only if the type is RECEIVED.\nWith SMS messages, it is not possible to link a reply directly with a specific sent message.  However, if you specified `REPLIABLE` in the `from` property, BulkSMS will link any reply to the most recent message sent to a given phone number.\n\nThe `relatedSentMessageId` property keeps the information about this link.\n\nYou can use this property to derive an implicit conversation from a set of messages.\n  - If a received reply message has a `relatedSentMessageId`, you can use it to retrieve the last message that was sent before the reply was received.\n  - If you have the `id` of the sent message and you want all the received messages that relate to it, you can use the List Related Messages Operation.\n',
    )
    status: Status = Field(..., description='The status of the message')
    submission: Optional[Submission] = Field(
        None, description='Identifies the submission.\n'
    )
    to: str = Field(..., description='The phone number of the recipient')
    type: Type1 = Field(..., description='The message direction')
    userSuppliedId: Optional[str] = Field(
        None,
        description='This is the value you supplied in the `userSuppliedId` field.\nHas a value only if the `type` is SENT.\n',
    )


class PhoneNumber(RootModel[str]):
    root: str = Field(
        ..., description='A phone number in E.164 format', examples=['44123456789']
    )


class FieldModel(BaseModel):
    name: Optional[str] = Field(
        None, description='The header name', examples=['x-amz-acl']
    )
    value: Optional[str] = Field(
        None, description='The header value', examples=['public-read']
    )


class PreSignInfo(BaseModel):
    fetchUrl: Optional[str] = Field(
        None,
        description='The URL you use in your SMS text.  It is the file location.',
        examples=['https://smsattach.it/bedhkd.pdf'],
    )
    fields: Optional[List[FieldModel]] = Field(
        None, description='Name value objects to add to the headers of the PUT request.'
    )
    putUrl: Optional[str] = Field(
        None,
        description='The address of the PUT request to upload the file.',
        examples=['https://some.place/aethzd.pdf?Token=IQoJb3JpZ2luX2EP3'],
    )


class PreSignRequest(BaseModel):
    fileExtension: Optional[str] = Field(
        None,
        description='The extension of the file.  Usually related to the media type.',
        examples=['pdf'],
    )
    mediaType: Optional[str] = Field(
        None,
        description='The media type of the file you would like to upload.  If you are not sure what value to use here, check out the standard [list of media types](https://www.iana.org/assignments/media-types/media-types.xhtml).',
        examples=['application/pdf'],
    )


class Address(BaseModel):
    city: Optional[str] = None
    country: Optional[str] = None
    postalCode: Optional[str] = None
    region: Optional[str] = None
    street: Optional[List[str]] = None


class Commerce(BaseModel):
    address: Optional[Address] = None
    bankPaymentReference: Optional[str] = None


class Company(BaseModel):
    name: Optional[str] = None
    taxReference: Optional[str] = None


class Credits(BaseModel):
    balance: Optional[float] = None
    isTransferAllowed: Optional[bool] = None
    limit: Optional[int] = None


class OriginAddresses(BaseModel):
    allowed: Optional[List[str]] = None
    isFullControlAllowed: Optional[bool] = None


class Quota(BaseModel):
    remaining: int = Field(
        ..., description='The number of messages you can still send today.'
    )
    size: int = Field(
        ...,
        description='The setting that limits the number of messages you can send in a day.',
    )


class Profile(BaseModel):
    commerce: Optional[Commerce] = None
    company: Optional[Company] = None
    created: datetime
    credits: Credits
    id: str
    originAddresses: Optional[OriginAddresses] = None
    quota: Quota
    username: str


class DeliveryReports(Enum):
    ALL = 'ALL'
    ERRORS = 'ERRORS'
    NONE = 'NONE'


class Type2(Enum):
    INTERNATIONAL = 'INTERNATIONAL'
    ALPHANUMERIC = 'ALPHANUMERIC'
    SHORTCODE = 'SHORTCODE'
    REPLIABLE = 'REPLIABLE'


class From(BaseModel):
    address: Optional[str] = Field(
        None,
        description='The address of the sender id.\n\nThe validation for this field depends on the value of the `type`.\nINTERNATIONAL can start with `+`. It has a maximum length of 15 digits, and has to be longer than 6 digits.\nALPHANUMERIC has a maximum length of 11 characters.\nSHORTCODE has a maximum length of 6 digits.\nREPLIABLE should not specify a value here.\n',
        examples=['1111111'],
    )
    type: Type2 = Field(
        ...,
        description='The type of the sender id.\n\nIf you want BulkSMS to collect replies to this message on your behalf, specify the type as REPLIABLE.  If the recipient is in a country where BulkSMS does not have a local reply number, the reply may incur costs that are more expensive than sending a local SMS in that country.\nIf you operate a service from a shortcode in a locale that allows messaging from such a shortcode, you can specify SHORTCODE for the type.\n',
    )


class MessageClass(Enum):
    FLASH_SMS = 'FLASH_SMS'
    ME_SPECIFIC = 'ME_SPECIFIC'
    SIM_SPECIFIC = 'SIM_SPECIFIC'
    TE_SPECIFIC = 'TE_SPECIFIC'


class ProtocolId(Enum):
    IMPLICIT = 'IMPLICIT'
    SHORT_MESSAGE_TYPE_0 = 'SHORT_MESSAGE_TYPE_0'
    REPLACE_MESSAGE_1 = 'REPLACE_MESSAGE_1'
    REPLACE_MESSAGE_2 = 'REPLACE_MESSAGE_2'
    REPLACE_MESSAGE_3 = 'REPLACE_MESSAGE_3'
    REPLACE_MESSAGE_4 = 'REPLACE_MESSAGE_4'
    REPLACE_MESSAGE_5 = 'REPLACE_MESSAGE_5'
    REPLACE_MESSAGE_6 = 'REPLACE_MESSAGE_6'
    REPLACE_MESSAGE_7 = 'REPLACE_MESSAGE_7'
    RETURN_CALL = 'RETURN_CALL'
    ME_DOWNLOAD = 'ME_DOWNLOAD'
    ME_DEPERSONALIZE = 'ME_DEPERSONALIZE'
    SIM_DOWNLOAD = 'SIM_DOWNLOAD'


class RoutingGroup(Enum):
    ECONOMY = 'ECONOMY'
    STANDARD = 'STANDARD'
    PREMIUM = 'PREMIUM'


class Type3(Enum):
    INTERNATIONAL = 'INTERNATIONAL'
    GROUP = 'GROUP'


class ToItem(BaseModel):
    address: Optional[str] = Field(
        None,
        description='The phone number of the recipient.  It must be supplied if the `type` is INTERNATIONAL',
    )
    fields: Optional[List[str]] = Field(
        None,
        description='Custom fields that can be used in the message body. A value can be given if the `type` is INTERNATIONAL\n\nRead the [body templates section](#tag/Message) for more information.\n',
    )
    id: Optional[str] = Field(
        None,
        description='The id of a group in your phonebook.  A value can be given if the `type` is GROUP.',
    )
    name: Optional[str] = Field(
        None,
        description='The name of a group in your phonebook. A value can be given if the `type` is GROUP.',
    )
    type: Optional[Type3] = Field(
        None, description='Type of the recipient. The default value is INTERNATIONAL.'
    )


class SubmissionEntry(BaseModel):
    body: str = Field(
        ...,
        description="The message content as described in the `encoding`. If the `encoding` is BINARY, the body must contain only hexadecimal digits where one byte is represented as two digits. For example, if you want to send two bytes '0x05' and '0x1F', the message body must contain the text '051F'.\n\nThe message content can also contain templates, read the [body templates section](#tag/Message) for more information.\n",
        examples=['Hi there!'],
    )
    deliveryReports: Optional[DeliveryReports] = Field(
        None,
        description='The type of delivery reports to request from the delivering network.\nThe default value  is `ALL`. Please note that not all networks support delivery reports.\nALL. All possible delivery reports\nERRORS. Only error delivery reports\nNONE. No delivery reports',
    )
    encoding: Optional[Encoding] = Field(
        None,
        description='Describes the content of the message body.\n\nTypically this is TEXT, which is the default if no value is provided.\n\nIf you need to send characters that are not covered by the [GSM 03.38](https://en.wikipedia.org/wiki/GSM_03.38) character set you will need to specify UNICODE.\n\nIf you want to send a sequence of bytes, you must use BINARY.\n\nYou can also or use the `auto-unicode` parameter of the Send Messages Operation.   \n\nIf you supply the value of `TEXT` while `auto-unicode` is `true` then your message may be converted to `UNICODE`.\n\nIf you supply a value other than `TEXT` for this property while `auto-unicode` is `true` then no automatic conversion will take place.\n',
    )
    from_: Optional[From] = Field(
        None,
        alias='from',
        description='Identifies the sender.\n\nInstead of a structured object, you can supply a string value here. \nIf you do this, the `type` of the sender is derived to be either INTERNATIONAL or ALPHANUMERIC.  If the value does not begin with a `+` and it contains at least one character that is not a digit, the type is detected as ALPHANUMERIC. Otherwise, the type is detected as INTERNATIONAL.\n',
    )
    longMessageMaxParts: Optional[int] = Field(
        None,
        description='The maximum number of message parts that can be used for a [concatenated message](https://en.wikipedia.org/wiki/Concatenated_SMS).\nThe default is `3`.\n',
        examples=[99],
    )
    messageClass: Optional[MessageClass] = Field(
        None,
        description='The class of the message, as specified by ยง4 of the GSM 03.38 specification.\n\nYou can provide either an integer value, or a mnemonic string.\n\nThe default value is SIM_SPECIFIC.\nNumeric values are\n| Name | Value|\n|------|------|\n| FLASH_SMS | 0      |\n| ME_SPECIFIC | 1    |\n| SIM_SPECIFIC | 2   |\n| TE_SPECIFIC | 3   |\n',
    )
    protocolId: Optional[ProtocolId] = Field(
        None,
        description='The TP-PID value from GSM 03.40[.750] ยง9.2.3.9.\n\nYou can provide either an integer value, or a mnemonic string.\n\nIf unspecified, this property defaults to `0`, representing the IMPLICIT value.\nNumeric values are listed below\n| Name | Value|\n|----- |------|\n| IMPLICIT              | 00 |\n| SHORT_MESSAGE_TYPE_0  | 64 |\n| REPLACE_MESSAGE_1     | 65 |\n| REPLACE_MESSAGE_2     | 66 |\n| REPLACE_MESSAGE_3     | 67 |\n| REPLACE_MESSAGE_4     | 68 |\n| REPLACE_MESSAGE_5     | 69 |\n| REPLACE_MESSAGE_6     | 70 |\n| REPLACE_MESSAGE_7     | 71 |\n| RETURN_CALL           | 95 |\n| ME_DOWNLOAD           | 125 |\n| ME_DEPERSONALIZE      | 126 |\n| SIM_DOWNLOAD          | 127 |\n',
    )
    routingGroup: Optional[RoutingGroup] = Field(
        None, description='Allows you to choose routing. The default is STANDARD.\n'
    )
    to: List[ToItem] = Field(
        ...,
        description='Identifies the recipients\n\nInstead of an array of structured objects, you can also provide a single object, a simple string or an array of strings.\nIf you supply a string, the `type` is taken as INTERNATIONAL.\n',
    )
    userSuppliedId: Optional[str] = Field(
        None,
        description='Correlate the messages created from this submission to your data.\n\nThe value can contain no more than 20 characters.\n',
        examples=['submission-12765'],
    )


class TransferEntry(BaseModel):
    commentOnFrom: Optional[str] = Field(
        None,
        description='An optional note that will be shown on the credit history of your account.\nThe maximum length of the comment is 100.\n',
        examples=['Tranfer to Bobby'],
    )
    commentOnTo: Optional[str] = Field(
        None,
        description="An optional note that will be shown on the credit history of the recipient's account.\nThe maximum length of the comment is 100.\n",
        examples=['Tranfer from Danny'],
    )
    credits: float = Field(
        ..., description='The amount of credits to transfer.\n', examples=[2345]
    )
    toUserId: float = Field(
        ...,
        description='The numeric user ID of the account that will receive the credits.\nThe ID must match the username.\n',
        examples=[2345],
    )
    toUsername: str = Field(
        ...,
        description='The username of the account that will receive the credits.\n',
        examples=['roboto'],
    )


class Webhook(BaseModel):
    active: Optional[bool] = Field(None, examples=[True])
    contactEmailAddress: Optional[str] = Field(None, examples=['tech_team@example.com'])
    id: Optional[float] = Field(None, examples=[234])
    name: Optional[str] = Field(None, examples=['My MT Webhook'])
    onWebApp: Optional[bool] = Field(None, examples=[True])
    triggerScope: Optional[str] = Field(None, examples=['SENT'])
    url: Optional[str] = Field(None, examples=['https://www.example.com'])


class InvokeOption(Enum):
    ONE = 'ONE'
    MANY = 'MANY'


class TriggerScope(Enum):
    SENT = 'SENT'
    RECEIVED = 'RECEIVED'


class WebhookEntry(BaseModel):
    active: Optional[bool] = Field(
        None,
        description='Indicates whether you want the webhook activated.\n\nIf the value is `true`, the webhook at the given `url` will be invoked with an empty array (`[]`) as part of the validation process.\nIf the webhook responds with a `2xx` status code, the submission is accepted; if not the webhook is not created (or updated).\n\nIf the value is `false` the webhook will be inactive, and it will not be invoked when messages are `SENT` or `RECEIVED`.\n\nThe default value is `true`.\n',
        examples=[True],
    )
    contactEmailAddress: Optional[str] = Field(
        None,
        description='The email address to which emails will be sent if there are problem with invoking the webhook.\n\nThe value must be a valid email address.\nIf this value is `null`, no email will be sent.\n\nIt is `null` by default.\n',
        examples=['tech_team@example.com'],
    )
    invokeOption: Optional[InvokeOption] = Field(
        None,
        description='Specifies how to invoke your webhook.\n\nIf the value is `ONE` the array POSTed to your webhook will contain no more than a single message.  Use this option if your webhook logic is unable to handle more than one messages at a time.\n\nIf the value is `MANY` the array POSTed to your webhook can contain up to 10 messages.  This is the recommended option.  The number of calls made to your webhook would be less and this will speed up your total processing time.\nIf your webhook fails for an invoke that has more than one message, each message in the array will automatically be retried one at a time. \n\nThis value defaults to `ONE` - but it is recommended that you set this property to `MANY`.\n',
        examples=['MANY'],
    )
    name: str = Field(
        ...,
        description='A text identifier for the webhook.\nMore than one webhook cannot have the same name.\n',
        examples=['My MT Webhook'],
    )
    onWebApp: Optional[bool] = Field(
        None,
        description='Indicates whether you want to show this webhook on the Web App.\n\nWebhooks shown there can be updated by the user that use the public Web site.\n\nThe default value is `true`.\n',
        examples=[True],
    )
    triggerScope: TriggerScope = Field(
        ...,
        description='Specifies when the webhook will be triggered.  \n\nPlease note the values are case sensitive.\n\nIf the value is `SENT`, the webhook will be called when a status update becomes available for a message you sent (i.e. a mobile terminating (MT) message).\n\nIf the value is `RECEIVED`, the webhook will be called when a message is received (i.e. a mobile originating (MO) message).\n\nNote that this field forces you to create two separate webhook entries if you want to collect all messages.  However,  you can use the same `url` for both webhooks if you want.\n',
        examples=['SENT'],
    )
    url: str = Field(
        ...,
        description='The location of the webhook.\n\nIn addition to being a [valid URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax), the url must also start with `http` or `https`.\n',
        examples=['https://www.example.com'],
    )


class BlockedNumbersPostRequest(RootModel[List[PhoneNumber]]):
    root: List[PhoneNumber]


class SortOrder(Enum):
    ASCENDING = 'ASCENDING'


class MessagesGetResponse(RootModel[List[Message]]):
    root: List[Message]


class MessagesPostRequest(RootModel[List[SubmissionEntry]]):
    root: List[SubmissionEntry]


class MessagesPostResponse(RootModel[List[Message]]):
    root: List[Message]


class MessagesSendGetResponse(RootModel[List[Message]]):
    root: List[Message]


class MessagesIdRelatedReceivedMessagesGetResponse(RootModel[List[Message]]):
    root: List[Message]


class WebhooksGetResponse(RootModel[List[Webhook]]):
    root: List[Webhook]


class BlockedNumber(BaseModel):
    id: float = Field(
        ...,
        description='A unique identifier that is assigned when the BlockedNumber is created.',
        examples=[234],
    )
    phoneNumber: PhoneNumber
